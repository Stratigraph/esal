# Event objects
#
# Copyright (c) 2015 Aubrey Barnard.  This is free software.  See
# LICENSE for details.

import collections

from . import general


# Export public API
__all__ = (
    'EVENT_FIELD_NAMES',
    'EVENT_HEADER',
    'Event',
    'Header',
    )


# An event in a sequence
EVENT_FIELD_NAMES = ('seq', 'time', 'dura', 'ev', 'val')
Event = collections.namedtuple('Event', EVENT_FIELD_NAMES)
Event.__doc__ = """
Event(sequence_id, start_time, duration, event, value)

An event is a tuple of values representing the occurrence of an event in
a sequence.  The fields are ordered so that events have a useful default
sort order and are as follows.  The fields can be accessed by index,
name, or attribute reference.

* sequence_id, 'seq': ID of the containing sequence
* start_time, 'time': When this event happened.  Can be integer, float,
  date, time, or datetime.
* duration, 'dura': How long the event lasted in a form compatible with
  the start time.  Can be omitted for point events.
* event, 'ev': Type of this event
* value, 'val': Value of this event.  Can be omitted for binary-valued
  events.

For example, a blood pressure measurement could be represented by the
following two events:

    Event(patient0123456789, '2015-04-25T11:39', None, bpSystolic, 120)
    Event(patient0123456789, '2015-04-25T11:39', None, bpDiastolic, 80)
""".lstrip()

# Override Event.__new__ to enable default values
def _event_new(cls, seq=None, time=None, dura=None, ev=None, val=None):
    # Copy from the source for Event.__new__ generated by namedtuple
    return tuple.__new__(cls, (seq, time, dura, ev, val))
_event_new.__doc__ = Event.__new__.__doc__
Event.__new__ = _event_new

# Override Event.__getitem__ to enable lookup by name
def _event_getitem(self, index):
    """Looks up event fields by name or index."""
    if isinstance(index, str):
        if index == 'seq':
            return self[0]
        elif index == 'time':
            return self[1]
        elif index == 'dura':
            return self[2]
        elif index == 'ev':
            return self[3]
        elif index == 'val':
            return self[4]
        else:
            raise KeyError(index)
    else:
        return super(Event, self).__getitem__(index)
Event.__getitem__ = _event_getitem

def _event_sort_key(self):
    return general.iterable_sort_key(self)
Event.sort_key = _event_sort_key


class Header:
    """A Header describes a collection of fields, like a tuple or a row
    in a table, by giving the fields names and indices.  This supports
    field access by name for objects without such existing support.
    """
    # TODO what about a sparse header (non-contiguous indices)?

    def __init__(self, names):
        """Creates a header using the given iterable of names, in order.
        """
        self.idxs_to_names = tuple(names)
        self.names_to_idxs = {}
        for index, name in enumerate(self.idxs_to_names):
            self.names_to_idxs[name] = index

    def __len__(self):
        """Returns the number of fields."""
        return len(self.idxs_to_names)

    def __getitem__(self, key):
        """Returns the index of the given key (name or index)."""
        if isinstance(key, int):
            if key < 0 or key >= len(self.idxs_to_names):
                raise IndexError(key)
            return key
        elif isinstance(key, str):
            return self.names_to_idxs[key]
        else:
            raise KeyError(key)

    def name_of(self, index):
        """Returns the name of the given index."""
        return self.idxs_to_names[index]

    def index_of(self, name):
        """Returns the index of the given name."""
        return self.names_to_idxs[name]

    def value_of(self, values, key):
        """Returns the value of the field with the given key (name or
        index).
        """
        return values[self.__getitem__(key)]


EVENT_HEADER = Header(EVENT_FIELD_NAMES)
